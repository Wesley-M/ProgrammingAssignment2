## These functions provide a way of caching inverse matrixes

## It receives a matrix object as an argument and returns
## a list of getter and setter methods for both the matrix 
## and its inverse.

makeCacheMatrix <- function(x = matrix()) {
    inverse <- NULL
    
    set <- function(y) {
        x <<- y
        inverse <<- NULL
    }
    
    get <- function() x
    
    set_inverse <- function(inv) inverse <<- inv
    get_inverse <- function() inverse
    
    list(set = set, get = get,
         set_inverse = set_inverse,
         get_inverse = get_inverse)
}


## It receives an object (generated by makeCacheMatrix),
## checks if the inverse of that matrix (defined inside that object)
## already has been defined (in which case the inverse is returned) 
## or it calculates the inverse and caches it inside the object.

cacheSolve <- function(x, ...) {
    inverse <- x$get_inverse()
    
    if(!is.null(inverse)) {
        return(invisible(inverse))
    }
    
    matrix <- x$get()
    inverse <- solve(matrix)
    
    # Caching the inverse matrix
    x$set_inverse(inverse)
    
    invisible(inverse)
}


# Some tests

# benchmark <- function(x, ...) {
#     start_time <- Sys.time()
#     x(...)
#     end_time <- Sys.time()
#     end_time - start_time
# }

# # Really large matrix
# m <- matrix(runif(1000000), 1000, 1000) 
# cm <- makeCacheMatrix(m)

# # Without cache
# cat("\nWithout cache: ", benchmark(cacheSolve, cm), "s", sep="")

# # With cache
# cat("\nWith cache: ", benchmark(cacheSolve, cm), "s\n", sep="")